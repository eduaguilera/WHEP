#' Bilateral trade data
#'
#' @description
#' Clean CSV data from the given `file_path`. It is recommended to use an
#' autogenerated path by `get_file_path()` function.
#'
#' @param file_path The local path where the input CSV is located
#'
#' @returns
#' A tibble with the reported trade between countries.
#' It contains the following columns:
#' - `year`: The year in which the recorded event occurred.
#' - `from_code`: FAOSTAT internal code for the country that is exporting the
#'    item. Equivalences with ISO 3166-1 numeric can be found in the
#'    _Area Codes_ CSV from the zip file that can be downloaded from
#'    [FAOSTAT](https://www.fao.org/faostat/en/#data/FBS). TODO: Think about
#'    this, would be nice to use ISO3 codes but won't be enough for our periods
#' - `to_code`: FAOSTAT internal code for the country that is importing the
#'    item. See previous `from_code`.
#' - `item`: Natural language name for the item that is being traded.
#' - `unit`: Measure unit for the traded item. It can have two values:
#'      - `"tonnes"`: Trade amount in tonnes (for crop and livestock products)
#'      - `"heads"`: Trade amount in number of animals (for live animal items)
#' - `value`: The amount traded in the corresponding measure unit.
#'
#' For the final data obtained, the export data was preferred, i.e.,
#' if country `"A"` says it exported `X` tonnes to country `"B"` but country
#' `"B"` claims they got `Y` tonnes from country `"A"`, we trust the export data
#' `X`. This choice is only needed if there exists a reported amount from both
#' sides. Otherwise, the single existing report is chosen.
#'
#' For each item and year, the total exports should match the total imports.
#' TODO: Balance data for this to be true.
#'
#' @export
#'
#' @examples
#' \dontrun{
#' get_bilateral_trade(get_file_path("bilateral_trade"))
#' }
get_bilateral_trade <- function(file_path) {
  cbs <- "commodity_balance_sheet" |>
    get_file_path() |>
    get_wide_cbs() |>
    dplyr::select(year, item, area_code, export, import)

  btd <-
    file_path |>
    readr::read_csv(show_col_types = FALSE) |>
    .clean_bilateral_trade()

  codes <- .get_all_country_codes(btd, cbs)

  btd |>
    .build_trade_matrices(cbs, codes) |>
    .fill_all_missing_trade(cbs) |>
    .balance_matrices()
}

.balance_matrices <- function(btd) {
  btd |>
    dplyr::mutate(
      bilateral_trade = purrr::map2(
        bilateral_trade,
        total_trade,
        .balance_matrix
      )
    )
}

.balance_matrix <- function(trade_matrix, total_trade) {
  exports <- total_trade |>
    dplyr::pull(export)
  imports <- total_trade |>
    dplyr::pull(import)

  stopifnot(abs(sum(exports) - sum(imports)) < 1e-4)
  stopifnot(length(exports) == length(imports))

  fitting <- mipfp::Ipfp(
    ifelse(trade_matrix == 0, 1, trade_matrix),
    target.list = list(1, 2),
    target.data = list(exports, imports),
    tol = 1e-1,
    tol.margins = 1e-1
  )
  balanced_matrix <- fitting$x.hat
  balanced_matrix
}

.balance_total_trade <- function(total_trade) {
  total_trade |>
    dplyr::mutate(
      total_export = sum(export),
      total_import = sum(import),
      export = ifelse(
        total_export > total_import,
        total_import * export / total_export,
        export
      ),
      import = ifelse(
        total_import > total_export,
        total_export * import / total_import,
        import
      )
    )
}

.clean_bilateral_trade <- function(btd) {
  btd |>
    dplyr::rename_with(tolower) |>
    dplyr::mutate(
      item = as.factor(item),
      unit = ifelse(unit == "Head", "heads", unit),
      from_code = ifelse(element == "Export", area_code, area_code_p),
      to_code = ifelse(element == "Export", area_code_p, area_code),
    ) |>
    .prefer_flow_direction("Export") |>
    dplyr::select(year, from_code, to_code, item, unit, value)
}

# Keep all rows with preferred direction (Import, Export)
# when both of them exist. Otherwise use the one present.
.prefer_flow_direction <- function(bilateral_trade, direction) {
  preferred_direction <- bilateral_trade |>
    dplyr::filter(element == direction)

  bilateral_trade |>
    dplyr::anti_join(
      preferred_direction,
      by = c("from_code", "to_code", "year", "item")
    ) |>
    dplyr::bind_rows(preferred_direction)
}

.fill_all_missing_trade <- function(btd, cbs) {
  btd |>
    dplyr::mutate(
      bilateral_trade = purrr::map2(
        bilateral_trade,
        total_trade,
        .fill_missing_trade
      )
    )
}

.fill_missing_trade <- function(trade_matrix, total_trade) {
  exports <- total_trade |>
    dplyr::pull(export)
  imports <- total_trade |>
    dplyr::pull(import)

  estimate <- .estimate_bilateral_trade(exports, imports)
  needed_estimates <- ifelse(is.na(trade_matrix), estimate, 0)
  balances <- max(0, exports - rowSums(trade_matrix, na.rm = TRUE))

  estimate <- purrr::map2(
    purrr::array_branch(needed_estimates, 1),
    balances,
    .downscale_large_estimates
  ) |>
    do.call(rbind, args = _)

  stopifnot(dim(trade_matrix) == dim(estimate))
  stopifnot(all(!is.na(estimate)))

  ifelse(is.na(trade_matrix), estimate, trade_matrix)
}

.downscale_large_estimates <- function(needed_estimates_row, balance) {
  estimates_sum <- sum(needed_estimates_row, na.rm = TRUE)
  if (0 < estimates_sum && estimates_sum > balance) {
    balance * needed_estimates_row / estimates_sum
  } else {
    needed_estimates_row
  }
}

.build_trade_matrices <- function(btd, cbs, codes) {
  btd |>
    dplyr::filter(unit == "tonnes") |>
    dplyr::select(-unit) |>
    .filter_only_items_in_cbs(cbs) |>
    tidyr::nest(
      bilateral_trade = c(from_code, to_code, value),
      .by = c(year, item)
    ) |>
    dplyr::left_join(.get_nested_cbs(cbs, codes), c("year", "item")) |>
    dplyr::mutate(
      bilateral_trade = purrr::map2(
        bilateral_trade,
        total_trade,
        ~ .build_trade_matrix(.x, .y, codes)
      )
    )
}

.get_nested_cbs <- function(cbs, codes) {
  cbs |>
    tidyr::nest(
      total_trade = c(area_code, export, import), .by = c(year, item)
    ) |>
    dplyr::mutate(
      total_trade = purrr::map(
        total_trade,
        function(total_trade) {
          total_trade |>
            .complete_total_trade(codes) |>
            .balance_total_trade()
        }
      )
    )
}

.complete_total_trade <- function(total_trade, codes) {
  total_trade |>
    tidyr::complete(
      area_code = codes,
      fill = list(export = 0, import = 0)
    ) |>
    dplyr::arrange(area_code)
}

.complete_faster <- function(total_trade, codes) {
  codes <- tibble::tibble(area_code = codes)

  codes |>
    dplyr::anti_join(total_trade, by = "area_code") |>
    dplyr::mutate(import = 0, export = 0) |>
    dplyr::bind_rows(total_trade) |>
    dplyr::arrange(area_code)
}

.filter_only_items_in_cbs <- function(btd, cbs) {
  btd_items <- btd |>
    dplyr::pull(item) |>
    unique() |>
    sort()

  cbs_items <- cbs |>
    dplyr::pull(item) |>
    unique() |>
    sort()

  # TODO: Also include these (need total export/import reports)
  items_not_in_cbs <- btd_items[!btd_items %in% cbs_items]

  btd |>
    dplyr::filter(!item %in% items_not_in_cbs)
}

.get_all_country_codes <- function(btd, cbs) {
  c(
    dplyr::pull(btd, from_code),
    dplyr::pull(btd, to_code),
    dplyr::pull(cbs, area_code)
  ) |>
    unique() |>
    sort()
}

.build_trade_matrix <- function(btd, total_trade, codes) {
  btd |>
    tidyr::complete(from_code = codes, to_code = codes) |>
    tidyr::pivot_wider(names_from = to_code, values_from = value) |>
    tibble::column_to_rownames(var = "from_code") |>
    as.matrix()
}

.estimate_bilateral_trade <- function(exports, imports) {
  if (sum(exports) == 0 || sum(imports) == 0) {
    return(matrix(0, nrow = length(exports), ncol = length(imports)))
  }
  est1 <- outer(exports, imports) / sum(imports)
  est2 <- outer(exports, imports) / sum(exports)
  (est1 + est2) / 2
}

# Get bilateral trade data in tidy format including estimates
# Quite useless because of high memory usage
.get_full_tidy_bilateral_trade <- function(file_path) {
  file_path |>
    get_bilateral_trade() |>
    dplyr::mutate(
      bilateral_trade = purrr::map(bilateral_trade, .convert_matrix_to_tidy)
    ) |>
    tidyr::unnest(cols = bilateral_trade) |>
    dplyr::select(-total_trade) |>
    dplyr::mutate(dplyr::across(c(from_code, to_code), as.integer))
}

.convert_matrix_to_tidy <- function(btd) {
  btd |>
    tibble::as_tibble() |>
    tibble::rownames_to_column(var = "from_code") |>
    tidyr::pivot_longer(
      setdiff(tidyr::everything(), tidyr::one_of("from_code")),
      names_to = "to_code"
    )
}
